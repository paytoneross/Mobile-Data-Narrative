<html>

<head>
    <title>Mobile Data Narrative</title>
    <link rel="stylesheet" href="style.css">
    <meta charset="utf-8">
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous">
        </script>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
</head>

<body>
    <!--300+ Word Narrative that describes my data.
    Answer these questions: 
    What conclusions can be made based on the data you collected?
    A conclusion must be drawn from each data visualization.-->
    <div class="container-fluid">
        <div class="row">
            <h1>Pearl Jam Data Narrative</h1>
        </div>
        <div class="row">
            <p>For my data narrative, I decided to write about Pearl Jam's 2024 world tour setlist data.</p>
            <p>&nbsp; &nbsp; &nbsp; &nbsp;I chose to write about this because Pearl Jam is one of my favorite bands, the
                new album they put out this year is killer,
                and the way they make their setlists is actually pretty interesting. Pearl Jam likes to write a unique
                setlist for
                every single show they play, and this makes their concerts super fun because you never know exactly what
                you are going to get.
                Because their setlists are always so unique, I wanted to analyze the data from their recent world tour
                and see what trends we can find.
            </p>
            <p>&nbsp; &nbsp; &nbsp; &nbsp;Specifically, I wanted to categorize songs based on their concert rarity and
                determine a rough likelyhood that each song could be played at any given show.
                We can use this data to predict certain key songs in the setlist, such as the main set opening and
                closing songs, as well as the encore opening and closing songs.
                And we can also group songs by record, and determine a likely spread of songs from each record that
                could be played at any given show.
            </p>
            <p>&nbsp; &nbsp; &nbsp; &nbsp;To ensure my data is accurate, I pulled the setlists from Pearl Jam's own
                website and then verified them through the website "setlist.fm"
                and the "Unofficial PJ Stat Tracker" fan app. I double verified them because Pearl Jam likes to "tag"
                songs within other songs, or just play
                snippits of certain songs and the official website doesn't always list those, so this makes sure I have
                the most accurate data possible. I also only used
                the data from their 2024 world tour, because the objective is to project likelyhood that songs could be
                played at future shows. The Dark Matter tour
                will obviously play a lot of songs from Dark Matter, so we can only guess how often these songs will be
                played in the future, but songs from past records
                will likely be played at a similar rate whenever Pearl Jam goes on tour again.
            </p>
        </div>
    </div>

    <div class="row table-responsive">
        <div class="col-md-3"></div>
        <div id='pjtable' class="col-md-6 table"></div>
        <div class="col-md-3"></div>
    </div>

    <script>
        const dataArray = [
            {
                showNumb: '1',
                city: 'Vancouver, Canada',
                date: '5/4/24',
                open: 'Wash',
                close: 'Setting Sun',
                total: '25',
            },
            {
                showNumb: '2',
                city: 'Vancouver, Canada',
                date: '5/6/24',
                open: 'Long Road',
                close: 'Setting Sun',
                total: '24',
            },
            {
                showNumb: '3',
                city: 'Portland, OR',
                date: '5/10/24',
                open: 'Release',
                close: 'Setting Sun',
                total: '25',
            },
            {
                showNumb: '21',
                city: 'Chicago, IL',
                date: '8/31/24',
                open: 'Garden',
                close: 'Little Wing',
                total: '25',
            },
            {
                showNumb: '23',
                city: 'New York, NY',
                date: '9/4/24',
                open: 'Garden',
                close: 'Yellow Ledbetter',
                total: '27',
            },
        ];
        //If we call this function without a parameter, by default it will use an empty array
        const createTable = (data = []) => {
            let table = `<table class="table table-dark text-center table-striped">
                <thead>
                    <tr>
                        <th>Show Number</th>
                        <th>City</th>
                        <th>Date</th>
                        <th>Opener</th>
                        <th>Closer</th>
                        <th>Total Songs</th>
                    </tr>
                </thead>
                <tbody>`;
            if (Array.isArray(data) && data.length > 0) {
                for (let x = 0; x < data.length; x++) {
                    //Create every row inside of the for loop
                    table += `<tr>
                    <td>${data[x].showNumb}</td>
                    <td>${data[x].city}</td>
                    <td>${data[x].date}</td>
                    <td>${data[x].open}</td>
                    <td>${data[x].close}</td>
                    <td>${data[x].total}</td>
                </tr>`;
                }
            }
            return table += `</tbody></table>`;
        }

        document.getElementById('pjtable').innerHTML = createTable(dataArray);
    </script>

    <div id="album_heatmap"></div>
    <script>

        // set the dimensions and margins of the graph
        var margin = { top: 80, right: 25, bottom: 30, left: 40 },
            width = 1200 - margin.left - margin.right,
            height = 1200 - margin.top - margin.bottom;

        // append the svg object to the body of the page
        var svg = d3.select("#album_heatmap")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform",
                "translate(" + margin.left + "," + margin.top + ")")
            .attr("align", "center");

        //Read the data
        d3.csv("https://raw.githubusercontent.com/paytoneross/Mobile-Data-Narrative/refs/heads/main/data.json", function (data) {

            // Labels of row and columns -> unique identifier of the column called 'group' and 'variable'
            var myGroups = d3.map(data, function (d) { return d.position; }).keys() //position / x axis / group
            var myVars = d3.map(data, function (d) { return d.album; }).keys() //album / y axis / variable

            // Build X scales and axis:
            var x = d3.scaleBand()
                .range([0, width])
                .domain(myGroups)
                .padding(0.05);
            svg.append("g")
                .style("font-size", 18)
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x).tickSize(0))
                .select(".domain").remove()

            // Build Y scales and axis:
            var y = d3.scaleBand()
                .range([height, 0])
                .domain(myVars)
                .padding(0.05);
            svg.append("g")
                .style("font-size", 5)
                .call(d3.axisLeft(y).tickSize(0))
                .select(".domain").remove()

            // create a tooltip
            var tooltip = d3.select("#album_heatmap")
                .append("div")
                .style("opacity", 0)
                .attr("class", "tooltip")
                .style("background-color", "white")
                .style("border", "solid")
                .style("border-width", "2px")
                .style("border-radius", "5px")
                .style("padding", "5px")

            // Three function that change the tooltip when user hover / move / leave a cell
            var mouseover = function (d) {
                tooltip
                    .style("opacity", 1)
                d3.select(this)
                    .style("stroke", "black")
                    .style("opacity", 1)
            }
            var mousemove = function (d) {
                tooltip
                    //<br> to start a new line
                    .html("Song Name: " + d.name + "<br>" + "Number of times played: " + d.count) //count / value
                    .style("left", (d3.mouse(this)[0] + 70) + "px")
                    .style("top", (d3.mouse(this)[1]) + "px")
                    .style("text-align", "center")
            }
            var mouseleave = function (d) {
                tooltip
                    .style("opacity", 0)
                d3.select(this)
                    .style("stroke", "none")
                    .style("opacity", function (d) { return (d.count / (d3.max(data, d => d.count))) }) //count / value
            }

            // add the squares
            svg.selectAll()
                .data(data, function (d) { return d.position + ':' + d.album; })
                .enter()
                .append("rect")
                .attr("x", function (d) { return x(d.position) }) //position / x axis / group
                .attr("y", function (d) { return y(d.album) }) //album / y axis / variable
                .attr("rx", 4)
                .attr("ry", 4)
                .attr("width", x.bandwidth())
                .attr("height", y.bandwidth())
                .style("fill", function (d) { return d.color })
                .style("stroke-width", 4)
                .style("stroke", "none")
                .style("opacity", function (d) { return (d.count / (d3.max(data, d => d.count))) })
                //.attr("fake", d => console.log((d.count / (d3.max(data, d => d.count)))))
                .on("mouseover", mouseover)
                .on("mousemove", mousemove)
                .on("mouseleave", mouseleave)
        })

        // Add title to graph
        svg.append("text")
            .attr("x", 0)
            .attr("y", -50)
            .attr("text-anchor", "center")
            .style("font-size", "30px")
            .text("Songs By Album:");

        // Add subtitle to graph
        svg.append("text")
            .attr("x", 0)
            .attr("y", -20)
            .attr("text-anchor", "center")
            .style("font-size", "18px")
            .style("fill", "black")
            .style("max-width", 400)
            .text("The darker the color, the more times the song was played.");
    </script>

    <!--div id="song_circle_pack"></div>
    <script>
        // set the dimensions and margins of the graph
        var width = 450
        var height = 450

        // append the svg object to the body of the page
        var svg = d3.select("#song_circle_pack")
            .append("svg")
            .attr("width", 450)
            .attr("height", 450)

        // create dummy data -> just one element per circle
        var data = [{ "name": "A" }, { "name": "B" }, { "name": "C" }, { "name": "D" }, { "name": "E" }, { "name": "F" }, { "name": "G" }, { "name": "H" }]

        // Initialize the circle: all located at the center of the svg area
        var node = svg.append("g")
            .selectAll("circle")
            .data(data)
            .enter()
            .append("circle")
            .attr("r", 25)
            .attr("cx", width / 2)
            .attr("cy", height / 2)
            .style("fill", "#69b3a2")
            .style("fill-opacity", 0.3)
            .attr("stroke", "#69a2b2")
            .style("stroke-width", 4)

        // Features of the forces applied to the nodes:
        var simulation = d3.forceSimulation()
            .force("center", d3.forceCenter().x(width / 2).y(height / 2)) // Attraction to the center of the svg area
            .force("charge", d3.forceManyBody().strength(0.5)) // Nodes are attracted one each other of value is > 0
            .force("collide", d3.forceCollide().strength(.01).radius(30).iterations(1)) // Force that avoids circle overlapping

        // Apply these forces to the nodes and update their positions.
        // Once the force algorithm is happy with positions ('alpha' value is low enough), simulations will stop.
        simulation
            .nodes(data)
            .on("tick", function (d) {
                node
                    .attr("cx", function (d) { return d.x; })
                    .attr("cy", function (d) { return d.y; })
            });
    </script-->
</body>

</html>